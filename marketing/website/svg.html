<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Naked Roadmap - Open Source Planning</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
  <defs>
    <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="5" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
    
    <radialGradient id="dotGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#00ffff" />
      <stop offset="100%" stop-color="#0088ff" />
    </radialGradient>
    
    <radialGradient id="dotGradientMagenta" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#ff00ff" />
      <stop offset="100%" stop-color="#ff0088" />
    </radialGradient>
    
    <radialGradient id="dotGradientPurple" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#8800ff" />
      <stop offset="100%" stop-color="#6600ff" />
    </radialGradient>
  </defs>
  
  <rect width="100%" height="100%" fill="#121220" />
  
  <g id="dotMatrix">
    <!-- Dots will be generated by script -->
  </g>
  
  <script type="text/javascript"><![CDATA[
    // Configuration
    const config = {
      gridSize: 20,
      dotRadius: 5,
      spacing: 22,
      fadeMinDuration: 2000,
      fadeMaxDuration: 7000,
      specialGradientChance: 0.3,
      revealDelay: 15000,   // Time before S appears
      revealDuration: 3000, // How long S stays visible
      cycleTime: 30000      // Total cycle time before repeating
    };
    
    // SVG namespace
    const svgNS = "http://www.w3.org/2000/svg";
    
    // Store all dots
    const dots = [];
    
    // Define S-shape pattern - 1 means part of the S
    const sPattern = [
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0],
      [0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
      [0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    // Get dot matrix container
    const dotMatrix = document.getElementById("dotMatrix");
    
    // Create the dot grid
    function createDotGrid() {
      const offset = (500 - (config.gridSize - 1) * config.spacing) / 2;
      
      for (let y = 0; y < config.gridSize; y++) {
        for (let x = 0; x < config.gridSize; x++) {
          const cx = offset + x * config.spacing;
          const cy = offset + y * config.spacing;
          
          // Choose gradient
          let fillId = "url(#dotGradient)";
          if (Math.random() < config.specialGradientChance) {
            fillId = Math.random() > 0.5 ? "url(#dotGradientMagenta)" : "url(#dotGradientPurple)";
          }
          
          // Create dot
          const dot = document.createElementNS(svgNS, "circle");
          dot.setAttribute("cx", cx);
          dot.setAttribute("cy", cy);
          dot.setAttribute("r", config.dotRadius);
          dot.setAttribute("fill", fillId);
          dot.setAttribute("opacity", "0");
          dot.setAttribute("filter", "url(#glow)");
          
          dotMatrix.appendChild(dot);
          
          // Store dot info
          dots.push({
            element: dot,
            x: x,
            y: y, 
            isPartOfS: sPattern[y] && sPattern[y][x] === 1,
            isAnimating: false
          });
          
          // Start random animation
          startRandomFade(dots[dots.length - 1]);
        }
      }
    }
    
    // Random fade animation for a dot
    function startRandomFade(dot) {
      if (dot.isAnimating) return;
      dot.isAnimating = true;
      
      const currentOpacity = parseFloat(dot.element.getAttribute("opacity"));
      const targetOpacity = currentOpacity > 0.5 ? 0 : Math.random() * 0.5 + 0.5;
      const duration = Math.random() * (config.fadeMaxDuration - config.fadeMinDuration) + config.fadeMinDuration;
      
      animateDot(dot, currentOpacity, targetOpacity, duration, () => {
        dot.isAnimating = false;
        // Queue next animation with slight delay
        setTimeout(() => startRandomFade(dot), Math.random() * 500);
      });
    }
    
    // Custom animation function
    function animateDot(dot, startOpacity, targetOpacity, duration, callback) {
      const startTime = Date.now();
      
      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function for smoother animation
        const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
        const newOpacity = startOpacity + (targetOpacity - startOpacity) * easedProgress;
        
        dot.element.setAttribute("opacity", newOpacity);
        
        if (progress < 1) {
          requestAnimationFrame(update);
        } else if (callback) {
          callback();
        }
      }
      
      update();
    }
    
    // Reveal the S shape
    function revealS() {
      dots.forEach(dot => {
        dot.isAnimating = true;
        
        const targetOpacity = dot.isPartOfS ? 1 : 0.2;
        animateDot(dot, parseFloat(dot.element.getAttribute("opacity")), targetOpacity, 1000, null);
      });
      
      // Hold the S shape for the reveal duration
      setTimeout(returnToRandom, config.revealDuration);
    }
    
    // Return to random pattern
    function returnToRandom() {
      dots.forEach(dot => {
        dot.isAnimating = false;
        startRandomFade(dot);
      });
      
      // Schedule next S reveal
      setTimeout(revealS, config.cycleTime - config.revealDuration);
    }
    
    // Initialize and start animations
    function init() {
      createDotGrid();
      
      // Schedule first S reveal
      setTimeout(revealS, config.revealDelay);
    }
    
    // Start once the SVG is loaded
    init();
  ]]></script>
</svg>

</body>
</html>